


项目拉下来后执行sql目录下的sso.sql文件后启动项目,然后访问这个路径可以得到结果
http://localhost:8081/ssoSystem/list

//aop和多数据源可以看见效果
http://localhost:8081/user/





需要处理的?
整理mybatisPlus 到笔记中,主要是分页参数传递,注意事项请参考:SsoSystemController


//Cglib动态代理实现方式
https://www.cnblogs.com/monkey0307/p/8328821.html

如何使用CGLIB:
1,需要 implements MethodInterceptor 接口并重写 intercept()方法;
2,通过Enhancer 增强类来调用

FastClass机制
 Cglib动态代理执行代理方法效率之所以比JDK的高是因为Cglib采用了FastClass机制，它的原理简单来说就是：为代理类和被代理类各生成一个Class，这个Class会为代理类或被代理类的方法分配一个index(int类型)。
这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。

VS
Cglib执行效率更高但生成代理类效率低


//nacos与eureka注册中心的对比
https://www.cnblogs.com/draymond/p/12725819.html
------------------------
微服务访问流程:
https://forezp.blog.csdn.net/article/details/115632826

@RestController
public class ConsumerController {

    @Autowired
    ProviderClient providerClient;//引入下面接口

    /**
     * 如果没有对接gateway时,用户直接从这里访问进入,然后通过feign转发到被访问端provider
     * @return
     */
    @GetMapping("/hi-feign")
    public String hiFeign(){
        return providerClient.hi("feign");
    }
}


/**
 *
 * @FeignClient注解就相当于httpClient,只是调用方才需要导入jar包,和被调方完全无关
 *
 * @FeignClient(value = "provider")
 * 上面的value值就是被调方的配置文件中的名字 spring.application.name: provider
 * 如果被调方有多个相同名字的provider,则会自动负载均衡
 */
@FeignClient(value = "provider")
public interface ProviderClient {

    /**
     * 调用被调的hi接口,参数key =name,不是必传的;注意这里只是相当于一个httpClient转发
     */
    @GetMapping("/hi")
    String hi(@RequestParam(value = "name", required = false) String name);
}

-----------------------------
//RabbitMQ系列（六）如何保证消息的顺序性、消息不丢失、不被重复消费,推荐
https://blog.csdn.net/weixin_45498465/article/details/105708875
RabbitMq 分为生产者确认和消费者确认,其中又有交换机确认和队列确认;上面这个链接消息不丢失主要讲的是消费者确认,当然也是最重要的环节,消费者确认等于生产者确认已经完成;


RabbitMq 代码代码实现主要思路?
消费者是通过监听队列名称来完成消费的;
生产者:会处理通过交换机类型来绑定到不同队列上去;可以有*或#;最总导致那些队列会放入消息;
一个服务中可以同时出现生产者和消费者;也可以只出现一种都是可以的;

-----------------------------
Redis的高并发和快速原因
1.redis是基于内存的，内存的读写速度非常快；
2.redis是单线程的，省去了很多上下文切换线程的时间；
3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。

IO多路复用技术
redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。
多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。
这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求

redis有三种集群方式：主从复制，哨兵模式和集群。

//高频面试题：Spring 如何解决循环依赖？
https://zhuanlan.zhihu.com/p/84267654



-------------------------
@RequestBody和@RequestParam区别
//https://www.cnblogs.com/muxi0407/p/11764140.html
或参看template项目的TestRequestBodyAndRequestPramController类下

public class TestRequetBody {

    /**
     * @JsonFormat用于后端传给前端的时间格式转换，
     * @DateTimeFormat用于前端传给后端的时间格式转换且是通过url?号方式
     *
     * 奇怪的是在请求进来的字符串json={"userName":"df","date":"2001-01-02 17:55:22"} 转
     * 日期对象类型时不加@JsonFormat会报错,这个注解网上一直说后端返回前端使用,但加了这个就不报错
     *
     * 第一种方式实体类通过日期类型接受把日期类型统一返回json格式;推荐
     * 第二种思路就是通过String类型接受和string类型返回,
     */
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss",timezone="GMT+8")
    @DateTimeFormat(pattern="yyyy-MM-dd HH:mm:ss")
    private Date date;

}


/**
 * 目的:postman请求类型为=application/json,方式为get,json={"userName":"df","date":"2001-01-02 17:55:22"}
 * 是否可以自动映射为对象
 * 结果:@RequestBody可以获取到请求体的数据,但只能获取到httpEntity的数据,且不能得到url?号方式的数据
 * 请求和返回时都请通过json格式交换数据
 */
@ResponseBody
@GetMapping("/all4")
public String findAllUser4(@RequestBody TestRequetBody user) throws Exception {
    logger.info("传入参数:{},{}",user.getUserName(),user.getDate());
    user.setDate(new Date());
    return JacksonUtils.obj2json(user);
}

最后总结:

@RequestParam 映射的url?上的键值对方式;得不到body体的数据,适合做单个参数的传递而不是对象类型,
主要特征还是从url上获取值,主要针对content-type=form-urlencode

@RequestBody可以获取到请求体的数据,但只能获取到httpEntity的数据,且不能得到url?号方式的数据
,json格式传递对象特别方便,content-type=appliction/json

get请求方法体也是可以带数据的;且可以通过requst.getReader()方法获取
-------------------------------------