


项目拉下来后执行sql目录下的sso.sql文件后启动项目,然后访问这个路径可以得到结果
http://localhost:8081/ssoSystem/list

//aop和多数据源可以看见效果
http://localhost:8081/user/





需要处理的?
整理mybatisPlus 到笔记中,主要是分页参数传递,注意事项请参考:SsoSystemController


//Cglib动态代理实现方式
https://www.cnblogs.com/monkey0307/p/8328821.html

如何使用CGLIB:
1,需要 implements MethodInterceptor 接口并重写 intercept()方法;
2,通过Enhancer 增强类来调用

FastClass机制
 Cglib动态代理执行代理方法效率之所以比JDK的高是因为Cglib采用了FastClass机制，它的原理简单来说就是：为代理类和被代理类各生成一个Class，这个Class会为代理类或被代理类的方法分配一个index(int类型)。
这个index当做一个入参，FastClass就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比JDK动态代理通过反射调用高。

VS
Cglib执行效率更高但生成代理类效率低


//nacos与eureka注册中心的对比
https://www.cnblogs.com/draymond/p/12725819.html

//RabbitMQ系列（六）如何保证消息的顺序性、消息不丢失、不被重复消费,推荐
https://blog.csdn.net/weixin_45498465/article/details/105708875
RabbitMq 分为生产者确认和消费者确认,其中又有交换机确认和队列确认;上面这个链接消息不丢失主要讲的是消费者确认,当然也是最重要的环节,消费者确认等于生产者确认已经完成;


RabbitMq 代码代码实现主要思路?
消费者是通过监听队列名称来完成消费的;
生产者:会处理通过交换机类型来绑定到不同队列上去;可以有*或#;最总导致那些队列会放入消息;
一个服务中可以同时出现生产者和消费者;也可以只出现一种都是可以的;


Redis的高并发和快速原因
1.redis是基于内存的，内存的读写速度非常快；
2.redis是单线程的，省去了很多上下文切换线程的时间；
3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。

IO多路复用技术
redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量。
多路-指的是多个socket连接，复用-指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。
这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求

redis有三种集群方式：主从复制，哨兵模式和集群。

//高频面试题：Spring 如何解决循环依赖？
https://zhuanlan.zhihu.com/p/84267654